package resourceprompts

import (
	"fmt"

	"github.com/g14a/tf/builder"
	"github.com/g14a/tf/types"
	"github.com/g14a/tf/validators"

	"github.com/fatih/color"
	"github.com/manifoldco/promptui"
)

func AWSAPIGatewayAccountPrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "cloudwatch_role_arn",
			Ex:    "",
			Doc: "(Optional) The ARN of an IAM role for CloudWatch (to allow logging & monitoring). " +
				"\nCheckout https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-stage-settings.html#how-to-stage-settings-console " +
				"\nLogging & monitoring can be enabled/disabled and otherwise tuned on the API Gateway Stage level.",
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	builder.ResourceBuilder("aws_api_gateway_account", blockName, resourceBlock)
}

func AWSAPIGatewayApiKeyPrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "name",
			Ex:    "",
			Doc:   "(Required) The name of the API key",
		},
		{
			Field: "description",
			Ex:    "",
			Doc:   "(Optional) The API key description. Defaults to \"Managed by Terraform\".",
		},
		{
			Field:     "enabled",
			Ex:        "(true/false)",
			Doc:       "(Optional) Specifies whether the API key can be used by callers. Defaults to true.",
			Validator: validators.BoolValidator,
		},
		{
			Field: "value",
			Ex:    "api-key-123",
			Doc:   "(Optional) The value of the API key. If not specified, it will be automatically generated by AWS on creation.",
		},
		{
			Field: "tags",
			Ex:    "k1=v1,k2=v2",
			Doc:   "(Optional) Key-value map of resource tags",
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	builder.ResourceBuilder("aws_api_gateway_api_key", blockName, resourceBlock)
}

func AWSAPIGatewayAuthorizerPrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "name",
			Ex:    "auth-name-123",
			Doc:   "(Required) The name of the authorizer",
		},
		{
			Field: "rest_api_id",
			Ex:    "rai-123",
			Doc:   "(Required) The ID of the associated REST API",
		},
		{
			Field: "identity_source",
			Ex:    "",
			Doc: "(Optional) The source of the identity in an incoming request. Defaults to method.request.header.Authorization. " +
				"\nFor REQUEST type, this may be a comma-separated list of values, including headers, query string parameters and stage variables - e.g. " +
				"\n\"method.request.header.SomeHeaderName,method.request.querystring.SomeQueryStringName,stageVariables.SomeStageVariableName\"",
		},
		{
			Type:  "select",
			Field: "type",
			Doc: "(Optional) The type of the authorizer. Possible values are TOKEN for a " +
				"\nLambda function using a single authorization token submitted in a " +
				"\ncustom header, REQUEST for a Lambda function using incoming request " +
				"\nparameters, or COGNITO_USER_POOLS for using an Amazon Cognito user pool. " +
				"\nDefaults to TOKEN",
			Items: []string{"TOKEN", "REQUEST", "COGNITO_USER_POOLS"},
		},
		{
			Field: "authorizer_credentials",
			Ex:    "",
			Doc: "(Optional) The credentials required for the authorizer. To specify an IAM Role for API Gateway " +
				"\nto assume, use the IAM Role ARN.",
		},
		{
			Field:     "authorizer_result_ttl_in_seconds",
			Ex:        "300",
			Doc:       "(Optional) The TTL of cached authorizer results in seconds. Defaults to 300",
			Validator: validators.IntValidator,
		},
		{
			Field: "identity_validation_expression",
			Ex:    "",
			Doc: "(Optional) A validation expression for the incoming identity. For TOKEN type, " +
				"\nthis value should be a regular expression. The incoming token from the client " +
				"\nis matched against this expression, and will proceed if the token matches. " +
				"\nIf the token doesn't match, the client receives a 401 Unauthorized response.",
		},
		{
			Field: "provider_arns",
			Ex:    "",
			Doc: "(Optional, required for type COGNITO_USER_POOLS) A list of the Amazon Cognito user pool ARNs. " +
				"\nEach element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}",
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	builder.ResourceBuilder("aws_api_gateway_authorizer", blockName, resourceBlock)
}

func AWSAPIGatewayBasePathMappingPrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "domain_name",
			Ex:    "",
			Doc:   "(Required) The already-registered domain name to connect the API to.",
		},
		{
			Field: "api_id",
			Ex:    "",
			Doc:   "(Required) The id of the API to connect.",
		},
		{
			Field: "stage_name",
			Ex:    "",
			Doc:   "(Optional) The name of a specific deployment stage to expose at the given path. If omitted, callers may select any stage by including its name as a path element after the base path.",
		},
		{
			Field: "base_path",
			Ex:    "",
			Doc:   "(Optional) Path segment that must be prepended to the path when accessing the API via this mapping. If omitted, the API is exposed at the root of the given domain.",
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	builder.ResourceBuilder("aws_api_gateway_base_path_mapping", blockName, resourceBlock)
}

func AWSAPIGatewayClientCertificatePrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "description",
			Ex:    "",
			Doc:   "(Optional) The description of the client certificate.",
		},
		{
			Field:     "tags",
			Ex:        "k1=v1,k2=v2",
			Doc:       "(Optional) Key-value map of resource tags",
			Validator: validators.RCValidator,
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	builder.ResourceBuilder("aws_api_gateway_client_certificate", blockName, resourceBlock)
}

func AWSAPIGatewayDeploymentPrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "rest_api_id",
			Ex:    "",
			Doc:   "(Required) The ID of the associated REST API",
		},
		{
			Field: "stage_name",
			Ex:    "",
			Doc:   "(Optional) The name of the stage. If the specified stage already exists, it will be updated to point to the new deployment. If the stage does not exist, a new one will be created and point to this deployment.",
		},
		{
			Field: "description",
			Ex:    "",
			Doc:   "(Optional) The description of the deployment",
		},
		{
			Field: "stage_description",
			Ex:    "",
			Doc:   "(Optional) The description of the stage",
		},
		{
			Field:     "tags",
			Ex:        "k1=v1,k2=v2",
			Doc:       "(Optional) Key-value map of resource tags",
			Validator: validators.RCValidator,
		},
		{
			Field:     "variables",
			Ex:        "k1=v1,k2=v2",
			Doc:       "(Optional) A map that defines variables for the stage",
			Validator: validators.RCValidator,
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	builder.ResourceBuilder("aws_api_gateway_deployment", blockName, resourceBlock)
}

func AWSAPIGatewayDocumentationPartPrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "properties",
			Ex:    "",
			Doc:   "(Required) A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., \"{ \\\"description\\\": \\\"The API does â€¦\\\" }\". Only Swagger-compliant key-value pairs can be exported and, hence, published.",
		},
		{
			Field: "rest_api_id",
			Ex:    "",
			Doc:   "(Required) The ID of the associated Rest API",
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	color.Green("\nEnter location:\n(Required) The location of the targeted API entity of the to-be-created documentation part.\n" +
		"The location block supports:" +
		"\n1.method\n2.name\n3.path\n4.status_code\n5.type")

	locationSchema := []types.Schema{
		{
			Field: "method",
			Ex:    "",
			Doc:   "(Optional) The HTTP verb of a method. The default value is * for any method.",
		},
		{
			Field: "name",
			Ex:    "",
			Doc:   "(Optional) The name of the targeted API entity.",
		},
		{
			Field: "path",
			Ex:    "",
			Doc:   "(Optional) The URL path of the target. The default value is / for the root resource.",
		},
		{
			Field: "status_code",
			Ex:    "",
			Doc:   "(Optional) The HTTP status code of a response. The default value is * for any status code.",
		},
		{
			Type:  "select",
			Field: "type",
			Doc:   "(Required) The type of API entity to which the documentation content applies.",
			Items: []string{"API", "METHOD", "REQUEST_BODY"},
		},
	}

	resourceBlock["location"] = builder.PSOrder(types.ProvidePS(locationSchema))

	builder.ResourceBuilder("aws_api_gateway_documentation_part", blockName, resourceBlock)
}

func AWSAPIGatewayDocumentationVersionPrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "version",
			Ex:    "",
			Doc:   "(Required) The version identifier of the API documentation snapshot.",
		},
		{
			Field: "rest_api_id",
			Ex:    "",
			Doc:   "(Required) The ID of the associated Rest API",
		},
		{
			Field: "description",
			Ex:    "",
			Doc:   "(Optional) The description of the API documentation version.",
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))
	builder.ResourceBuilder("aws_api_gateway_documentation_version", blockName, resourceBlock)
}

// aws_api_gateway_domain_name
func AWSAPIGatewayDomainNamePrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "domain_name",
			Ex:    "",
			Doc:   "(Required) The fully-qualified domain name to register",
		},
		{
			Field: "certificate_arn",
			Ex:    "",
			Doc: "(Optional) The ARN for an AWS-managed certificate. " +
				"\nAWS Certificate Manager is the only supported source. " +
				"\nUsed when an edge-optimized domain name is desired. " +
				"\nConflicts with certificate_name, certificate_body, " +
				"\ncertificate_chain, certificate_private_key, regional_certificate_arn," +
				"\nand regional_certificate_name.",
		},
		{
			Field: "regional_certificate_arn",
			Ex:    "",
			Doc: "(Optional) The ARN for an AWS-managed certificate. " +
				"\nAWS Certificate Manager is the only supported source. " +
				"\nUsed when a regional domain name is desired. Conflicts " +
				"\nwith certificate_arn, certificate_name, certificate_body, " +
				"\ncertificate_chain, and certificate_private_key",
		},
		{
			Field: "certificate_name",
			Ex:    "",
			Doc:   "(Optional) The unique name to use when registering this certificate as an IAM server certificate. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name. Required if certificate_arn is not set.",
		},
		{
			Field: "certificate_body",
			Ex:    "",
			Doc:   "(Optional) The certificate issued for the domain name being registered, in PEM format. Only valid for EDGE endpoint configuration type. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name",
		},
		{
			Field: "certificate_chain",
			Ex:    "",
			Doc:   "(Optional) The certificate for the CA that issued the certificate, along with any intermediate CA certificates required to create an unbroken chain to a certificate trusted by the intended API clients. Only valid for EDGE endpoint configuration type. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name",
		},
		{
			Field: "certificate_private_key",
			Ex:    "",
			Doc:   "(Optional) The private key associated with the domain certificate given in certificate_body. Only valid for EDGE endpoint configuration type. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name",
		},
		{
			Field: "regional_certificate_name",
			Ex:    "",
			Doc:   "(Optional) The user-friendly name of the certificate that will be used by regional endpoint for this domain name. Conflicts with certificate_arn, certificate_name, certificate_body, certificate_chain, and certificate_private_key.",
		},
		{
			Type:  "select",
			Field: "security_policy",
			Doc:   "(Optional) The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2. Must be configured to perform drift detection.",
			Items: []string{"TLS_1_0", "TLS_1_2"},
		},
		{
			Field:     "tags",
			Ex:        "k1=v1,k2=v2",
			Doc:       "(Optional) Key-value map of resource tags",
			Validator: validators.RCValidator,
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	color.Yellow("\nConfigure nested settings like endpoint_configuration/tags [y/n]?\n\n", "text")

	ynPrompt := promptui.Prompt{
		Label: "",
	}

	yn, err := ynPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	if yn == "n" || yn == "" {
		builder.ProviderBuilder("aws_api_gateway_domain_name", resourceBlock)
		return
	}

	endpointConfigSchema := []types.Schema{
		{
			Field: "types",
			Ex:    "",
			Doc: "(Required) A list of endpoint types. This resource currently only supports " +
				"\nmanaging a single value. Valid values: EDGE or REGIONAL. If unspecified, " +
				"\ndefaults to EDGE. Must be declared as REGIONAL in non-Commercial partitions. " +
				"\nRefer to the documentation for more information on the difference between " +
				"\nedge-optimized and regional APIs.",
			Items: []string{"EDGE", "REGIONAL"},
		},
	}

	resourceBlock["endpoint_configuration"] = builder.PSOrder(types.ProvidePS(endpointConfigSchema))
	builder.ResourceBuilder("aws_api_gateway_domain_name", blockName, resourceBlock)
}

func AWSAPIGatewayGatewayResponsePrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "rest_api_id",
			Ex:    "",
			Doc:   "(Required) The string identifier of the associated REST API.",
		},
		{
			Field: "response_type",
			Ex:    "",
			Doc:   "(Required) The response type of the associated GatewayResponse.",
		},
		{
			Field: "status_code",
			Ex:    "",
			Doc:   "(Optional) The HTTP status code of the Gateway Response.",
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	color.Green("\nEnter response_templates:\n(Optional) A map specifying the templates used to transform the response body.")

	responseTemplatesSchema := []types.Schema{
		{
			Field: "application/json",
			Ex:    "",
			Doc:   "Check https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_gateway_response",
		},
	}

	resourceBlock["response_templates"] = builder.PSOrder(types.ProvidePS(responseTemplatesSchema))

	builder.ResourceBuilder("aws_api_gateway_account", blockName, resourceBlock)
}

func AWSAPIGatewayIntegrationPrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "rest_api_id",
			Ex:    "",
			Doc:   "(Required) The ID of the associated REST API.",
		},
		{
			Field: "resource_id",
			Ex:    "",
			Doc:   "(Required) The API resource ID.",
		},
		{
			Type:  "select",
			Field: "http_method",
			Doc:   "(Required) The HTTP method",
			Items: []string{"GET", "POST", "PUT", "DELETE", "HEAD", "OPTION", "ANY"},
		},
		{
			Type:  "select",
			Field: "integration_http_method",
			Doc: "(Optional) The integration HTTP method specifying how API Gateway will interact with the back end. " +
				"\nRequired if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY. Not all methods are compatible with all AWS integrations. " +
				"\ne.g. Lambda function can only be invoked via POST." +
				"\nCheckout https://github.com/awslabs/aws-apigateway-importer/issues/9#issuecomment-129651005",
			Items: []string{"GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONs", "ANY", "PATCH"},
		},
		{
			Type:  "select",
			Field: "type",
			Doc: "(Required) The integration input's type. An HTTP or HTTP_PROXY integration with a connection_type " +
				"\nof VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC." +
				"\nCheckout https://docs.aws.amazon.com/apigateway/api-reference/resource/integration/",
			Items: []string{"HTTP", "MOCK", "AWS", "AWS_PROXY", "HTTP_PROXY"},
		},
		{
			Type:  "select",
			Field: "connection_type",
			Doc: "(Optional) The integration input's connectionType. Valid values are INTERNET (default for " +
				"\nconnections through the public routable internet), and VPC_LINK (for private connections " +
				"\nbetween API Gateway and a network load balancer in a VPC)." +
				"\nCheckout https://docs.aws.amazon.com/apigateway/api-reference/resource/integration/#connectionType",
			Items: []string{"INTERNET", "VPC_LINK"},
		},
		{
			Field: "connection_id",
			Ex:    "",
			Doc:   "(Optional) The id of the VpcLink used for the integration. Required if connection_type is VPC_LINK",
		},
		{
			Field: "uri",
			Ex:    "",
			Doc: "(Optional) The input's URI. Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY. " +
				"\nFor HTTP integrations, the URI must be a fully formed, encoded HTTP(S) URL according " +
				"\nto the RFC-3986 specification." +
				"\nCheckout https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_integration#uri",
		},
		{
			Field: "credentials",
			Ex:    "",
			Doc: "(Optional) The credentials required for the integration. For AWS integrations, 2 options are available. " +
				"\nTo specify an IAM Role for Amazon API Gateway to assume, use the role's ARN. To require that the " +
				"\ncaller's identity be passed through from the request, specify the string arn:aws:iam::\\*:user/\\*",
		},
		{
			Type:  "select",
			Field: "passthrough_behavior",
			Doc:   "(Optional) The integration passthrough behavior",
			Items: []string{"WHEN_NO_MATCH", "WHEN_NO_TEMPLATES", "NEVER"},
		},
		{
			Field: "cache_key_parameters",
			Ex:    "",
			Doc:   "(Optional) A list of cache key parameters for the integration.",
		},
		{
			Field: "cache_namespace",
			Ex:    "",
			Doc:   "(Optional) The integration's cache namespace.",
		},
		{
			Type:  "select",
			Field: "content_handling",
			Doc: "(Optional) Specifies how to handle request payload content type conversions. " +
				"\nIf this property is not defined, the request payload will be passed through " +
				"\nfrom the method request to integration request without modification, provided " +
				"\nthat the passthroughBehaviors is configured to support payload pass-through.",
			Items: []string{"CONVERT_TO_BINARY", "CONVERT_TO_TEXT"},
		},
		{
			Field:     "timeout_milliseconds",
			Ex:        "",
			Doc:       "(Optional) Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds.",
			Validator: validators.MinMaxIntValidator(50, 29000),
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	builder.ResourceBuilder("aws_api_gateway_integration", blockName, resourceBlock)
}

func AWSAPIGatewayIntegrationResponsePrompt() {
	color.Green("\nEnter block name(Required) e.g. foo/bar\n\n")
	blockPrompt := promptui.Prompt{
		Label: "",
	}

	blockName, err := blockPrompt.Run()
	if err != nil {
		fmt.Println(err)
	}

	schema := []types.Schema{
		{
			Field: "rest_api_id",
			Ex:    "",
			Doc:   "(Required) The ID of the associated REST API",
		},
		{
			Field: "resource_id",
			Ex:    "",
			Doc:   "(Required) The API resource ID",
		},
		{
			Type:  "select",
			Field: "http_method",
			Doc:   "(Required) The HTTP method",
			Items: []string{"GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "ANY"},
		},
		{
			Field: "status_code",
			Ex:    "",
			Doc:   "(Required) The HTTP status code",
		},
		{
			Field: "selection_pattern",
			Ex:    "",
			Doc: "(Optional) Specifies the regular expression pattern used to choose " +
				"\nan integration response based on the response from the backend. " +
				"\nOmit configuring this to make the integration the default one. " +
				"\nIf the backend is an AWS Lambda function, the AWS Lambda function " +
				"\nerror header is matched. For all other HTTP and AWS backends, " +
				"\nthe HTTP status code is matched.",
		},
		{
			Type:  "select",
			Field: "content_handling",
			Doc: "(Optional) Specifies how to handle request payload content type conversions. " +
				"\nSupported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property " +
				"\nis not defined, the response payload will be passed through from the integration " +
				"\nresponse to the method response without modification.",
			Items: []string{"CONVERT_TO_BINARY", "CONVERT_TO_TEXT"},
		},
		{
			Field: "response_templates",
			Ex:    "k1=v1,k2=v2",
			Doc:   "(Optional) A map specifying the templates used to transform the integration response body",
			Validator: validators.RCValidator,
		},
		{
			Field: "response_parameters",
			Ex:    "k1=v1,k2=v2",
			Doc:   "(Optional) A map of response parameters that can be read from the backend response. For example: response_parameters = { \"method.response.header.X-Some-Header\" = \"integration.response.header.X-Some-Other-Header\" }",
			Validator: validators.RCValidator,
		},
	}

	resourceBlock := builder.PSOrder(types.ProvidePS(schema))

	builder.ResourceBuilder("aws_api_gateway_integration_response", blockName, resourceBlock)
}
